//! Code generation routes

use axum::{
    extract::State,
    Json,
};
use serde::Serialize;

use crate::{AppState, ApiError};

/// Generated code response
#[derive(Debug, Serialize)]
pub struct GeneratedCode {
    pub files: Vec<GeneratedFile>,
}

#[derive(Debug, Serialize)]
pub struct GeneratedFile {
    pub path: String,
    pub content: String,
}

/// Generate frontend code (React)
pub async fn generate_frontend(
    State(state): State<AppState>,
) -> Result<Json<GeneratedCode>, ApiError> {
    let project = state.get_project().await
        .ok_or_else(|| ApiError::NotFound("No project loaded".into()))?;
    
    // Generate React App.tsx
    let app_content = format!(r#"// Generated by Grapes IDE
import React from 'react';
import {{ BrowserRouter as Router, Routes, Route }} from 'react-router-dom';

// Pages
{}

function App() {{
  return (
    <Router>
      <Routes>
{}
      </Routes>
    </Router>
  );
}}

export default App;
"#,
        project.pages.iter()
            .filter(|p| !p.archived)
            .map(|p| format!("import {} from './pages/{}';\n", pascal_case(&p.name), p.name))
            .collect::<String>(),
        project.pages.iter()
            .filter(|p| !p.archived)
            .map(|p| format!("        <Route path=\"{}\" element={{<{} />}} />\n", p.path, pascal_case(&p.name)))
            .collect::<String>()
    );
    
    let package_json = serde_json::json!({
        "name": project.name.to_lowercase().replace(" ", "-"),
        "version": "1.0.0",
        "private": true,
        "dependencies": {
            "react": "^18.2.0",
            "react-dom": "^18.2.0",
            "react-router-dom": "^6.20.0"
        },
        "scripts": {
            "start": "vite",
            "build": "vite build"
        },
        "devDependencies": {
            "vite": "^5.0.0",
            "@vitejs/plugin-react": "^4.2.0"
        }
    });
    
    Ok(Json(GeneratedCode {
        files: vec![
            GeneratedFile {
                path: "src/App.tsx".into(),
                content: app_content,
            },
            GeneratedFile {
                path: "package.json".into(),
                content: serde_json::to_string_pretty(&package_json).unwrap(),
            },
        ],
    }))
}

/// Generate backend code (NestJS)
pub async fn generate_backend(
    State(state): State<AppState>,
) -> Result<Json<GeneratedCode>, ApiError> {
    let project = state.get_project().await
        .ok_or_else(|| ApiError::NotFound("No project loaded".into()))?;
    
    // Generate main.ts
    let main_content = r#"// Generated by Grapes IDE
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableCors();
  await app.listen(3000);
}
bootstrap();
"#;
    
    // Generate controllers
    let mut files = vec![
        GeneratedFile {
            path: "src/main.ts".into(),
            content: main_content.into(),
        },
    ];
    
    // Generate controller for each API
    for api in project.apis.iter().filter(|a| !a.archived) {
        let controller_content = format!(r#"// Generated by Grapes IDE
import {{ Controller, {method} }} from '@nestjs/common';

@Controller('{base_path}')
export class {name}Controller {{
  @{method}()
  async handle{name}() {{
    // TODO: Implement logic
    return {{ success: true }};
  }}
}}
"#,
            method = format!("{:?}", api.method),
            base_path = api.path.trim_start_matches('/'),
            name = pascal_case(&api.name),
        );
        
        files.push(GeneratedFile {
            path: format!("src/controllers/{}.controller.ts", api.name.to_lowercase().replace(" ", "-")),
            content: controller_content,
        });
    }
    
    Ok(Json(GeneratedCode { files }))
}

/// Generate database schema (Prisma)
pub async fn generate_database(
    State(state): State<AppState>,
) -> Result<Json<GeneratedCode>, ApiError> {
    let project = state.get_project().await
        .ok_or_else(|| ApiError::NotFound("No project loaded".into()))?;
    
    let mut schema = String::from("// Generated by Grapes IDE\n\n");
    schema.push_str("datasource db {\n  provider = \"sqlite\"\n  url      = \"env(\"DATABASE_URL\")\"\n}\n\n");
    schema.push_str("generator client {\n  provider = \"prisma-client-js\"\n}\n\n");
    
    for model in project.data_models.iter().filter(|m| !m.archived) {
        schema.push_str(&format!("model {} {{\n", model.name));
        
        for field in &model.fields {
            let prisma_type = match field.field_type {
                crate::schema::data_model::FieldType::String => "String",
                crate::schema::data_model::FieldType::Int => "Int",
                crate::schema::data_model::FieldType::Float => "Float",
                crate::schema::data_model::FieldType::Boolean => "Boolean",
                crate::schema::data_model::FieldType::DateTime => "DateTime",
                crate::schema::data_model::FieldType::Json => "Json",
                crate::schema::data_model::FieldType::Uuid => "String",
                crate::schema::data_model::FieldType::Email => "String",
                crate::schema::data_model::FieldType::Url => "String",
                crate::schema::data_model::FieldType::Bytes => "Bytes",
                crate::schema::data_model::FieldType::Text => "String",
            };
            
            let mut line = format!("  {} {}", field.name, prisma_type);
            if !field.required { line.push('?'); }
            if field.primary_key { line.push_str(" @id"); }
            if field.unique { line.push_str(" @unique"); }
            
            if let Some(default) = &field.default_value {
                match default {
                    crate::schema::data_model::DefaultValue::Uuid => line.push_str(" @default(uuid())"),
                    crate::schema::data_model::DefaultValue::Now => line.push_str(" @default(now())"),
                    crate::schema::data_model::DefaultValue::AutoIncrement => line.push_str(" @default(autoincrement())"),
                    crate::schema::data_model::DefaultValue::Static { value } => line.push_str(&format!(" @default({})", value)),
                    _ => {}
                }
            }
            
            schema.push_str(&format!("{}\n", line));
        }
        
        if model.timestamps {
            schema.push_str("  createdAt DateTime @default(now())\n");
            schema.push_str("  updatedAt DateTime @updatedAt\n");
        }
        
        schema.push_str("}\n\n");
    }
    
    Ok(Json(GeneratedCode {
        files: vec![
            GeneratedFile {
                path: "prisma/schema.prisma".into(),
                content: schema,
            },
        ],
    }))
}

/// Convert string to PascalCase
fn pascal_case(s: &str) -> String {
    s.split(|c: char| !c.is_alphanumeric())
        .filter(|w| !w.is_empty())
        .map(|w| {
            let mut chars = w.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().chain(chars).collect(),
            }
        })
        .collect()
}
